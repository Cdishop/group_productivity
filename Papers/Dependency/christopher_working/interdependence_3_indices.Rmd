---
output: pdf_document
---

## Theoretical Indices

Researchers have also operationalized interdependence by presenting a number of formalas or methods for calculating an interdependence value outside of any perception by an individual emeshed within the task network. An index of task interdependence, for example, could come from a count of the number of task precedence relationships that exist in a unit, or, in other words, the number of tasks that require other tasks to be completed before they themselves can occur. The value of interdependence in these measures, therefore, comes from the researcher either presuming task relationships and structure in a theory or observing it in the field, although the latter is far less common.

Table 3 depicts interdependence indices. The first five come from the organizational science literature, whereas the last three are pulled from the computer science and software engineering literatures. Indices provided by @obrien_measurement_1968 and others cohere most directly with the notion of task interdependence represented in self reports, so we begin there. First, consider task precedence indices provided by @obrien_measurement_1968, @wood_task_1986, and @oeser1967mathematical -- row one of Table 3. These indices quantify the amount of precedence relationships in a task network. As shown in the images, when task one must be completed before task two, which must be completed before task three, which must be completed before task four, the index is greater than when tasks one, two, and three feed into task four but none of the first three tasks require precedent completions. In other words, a low value of the index means that tasks can be completed irrespective of the status of other tasks, performance on one does not depend on the performance or completion of another. @oeser1967mathematical originally introduced this index simply as the "task by task" matrix in their structural role theory, which was adopted and transformed slightly by @obrien_measurement_1968 and called the inter-task coordination index, and later used as part of a task complexity taxonomy by @wood_task_1986 and labeled coordinative complexity. The index associated with Oeser and O'Brien's (1967) task by task matrix can take on any positive, real value (zero included), whereas the inter-task coordination index provided by O'Brien (1968) is bounded by 0 and 1. Wood's (1986) coordinative complexity index is identical to O'Brien's (1968) inter-task coordination index. Note that the values we use in the example image include 10 and 3, so they come from Oeser and O'Brien's (1967) task by task matrix, but the other index would also classify the first task structure as more interdependent given the greater number of precedence relationships. 

![](images/table3a.png)

Row two of Table 3 presents another common theoretical task interdependence index that is often ignored or confounded in self report ratings: the extent to which individuals work jointly on tasks. Now, the emphasis is not on precedence relationships or the extent to which tasks must be completed before others, but on the allocation of people to tasks and the extent to which people overlap in those assignments. To what extent is a given task completed by a single or multiple individuals? Oeser and Frank [-@oeser1964mathematical; -@oeser1962mathematical] originally introduced this index in their person by task matrix within structural role theory, and, as with the other index, O'Brien (1968) later adopted it and provided a scaling between 0 and 1 that he called inter-position collaboration. The images show two possible ways to assign two individuals to two tasks. In the first, each task is completed by a single individual so the index takes on a low value, whereas the index increases for the second arrangement where task one undergoes joint performance by both individuals. 

The next row of Table 3 describes the NK model of interdependence presented in the strategy literature by @lenox_interdependency_2007. This index captures the complexity of task or activity configurations within a unit. Imagine a unit or team with four tasks, A, B, C, and D, and assume that A depends on B and there are no other task dependencies. Take task A to be "training" and task B to be "find a manager to train the unit," where each can take on a binary value, 0 or 1, in which the options for A include error management or active learning whereas those for B include two different managers, Joe and Kelly. We can represent an arrangement in a task vector, such as [0, 1], which, in this case, means that the unit received error management training by Kelly, whereas the vector [1, 1] would mean that the unit received active learning training by Kelly. Given that A depends on B in this example, there are four task vectors that may produce unique values of performance for the unit: [0, 0], [0, 1], [1, 0], and [1, 1]. Said differently, the results of tasks A and B with respect to unit performance (or any other relevant outcome) could potentially differ in four ways due to the task arrangements that stem from interdependence. When task A depends not only on B but also on C, there are eight unique (binary) configurations, and when A then also depends on D there are 16 unique (binary) configurations. This index, therefore, represents the increasing number of potential results as tasks begin to depend on one another. 

![](images/table3b.png)

The next three task interdependence indices in Table 3 come from software engineering and computer science: syntactic, workflow, and logical dependency. Before discussing them, it helps to briefly unpack common work activities for programmers. Imagine an individual who writes a script that will eventually become a website for a blog about cooking, music, and current events. The blog contains posts about the various topics, images displayed on each page, an interesting design in the background, links to similar material on other sites, and compiled reports on US trends garnered from scraping data from other places on the web. Often, code for different tasks will be stored within different scripts. One script may scrape and clean data from the web while another searches for and prepares links to other relevant material. A third script contains the text for each post, a fourth prepares images and charts. A master script then references each of these individual scripts and ultimately compiles the website, and, back down a level of abstraction, each individual script may reference yet other scripts that initiate basic functions and objects. All of the ways in which these various scripts "reference" one another, or pull code from different sources, creates dependence in a similar way that tasks more familiar to organizational psychologists do. The other aspect that merits attention before discussing dependence is commits. After writing code for one or several files, a programmer then commits her changes either to be checked by others or maintained indefinitely by the website. With these basic notions in mind, syntactic, workflow, and logical become easier to understand.

Syntactic dependency refers to the number of code references either across all scripts or within a single file. When Justin's code references two other files, A and B, his script is said to have less syntactic dependency than Rachel's code that references six other files. It can also be applied to the entire workflow of the unit to be compared with another. Think back to the cooking, music, and current events blog mentioned above, perhaps its code, as an entire unit, contains greater syntactic dependency than the files, as a unit, from another site on sports commentators within the US. Whenever a script or set of scripts reaches elsewhere for additional code, syntactic dependency increases. 

Logical dependency is similar, but it incorporates commits. Essentially, this index captures the extent to which files, when worked on, require other scripts to be updated as well within the same commit. [More here after working out note within table]. 

Workflow dependency, finally, is the degree centrality of the person with the greatest degree centrality out of all of the people working on a script. Imagine two different scripts, A and B, each with an assortment of different people writing their code. Susie, Sarah, Savannah, Sam, and Sheryl write code within script A, whereas Robert, Rachel, Rome, Rupert, and Robin write code within script B. Out of all the people working on script B, Rome has the greatest degree centrality (4). Sarah, on the other hand, has the greatest degree centrality out of all of the people working on script A (10). Script A, then, is said to have greater workflow dependency than script B. 

Indices of outcome, rather than task, interdependence were presented in @victor_interdependence_1987 writing on interdependence theory. They unpacked what is essentially a game theory framework for describing and quantifying actions and outcomes for two or more individuals. The matrix representation used in their paper is identical to normal form games in economics where players are situated either on the row or the column, along with their possible actions, and the values in the matrix represent the rewards, outcomes, or utilities for the row/column player. The example reprinted in Table 3, for instance, shows that the sales manager receives an outcome of 5 when she conducts action A2 while the credit manager conducts action B1. All of the examples described in their theory use actions and activities, but the ideas generalize to tasks as well. The index that we draw attention to is a number that Victor and Blackburn (1987) call the index of dependence that captures the extent to which the rewards/outcomes for one player are determined by the other player's tasks or actions (this number is not the specific value within an outcome matrix, such as 5 or -4 in the top right cell). For example, for a given move by the credit manager, the sales manager does not change her outcome by switching from action (task) A1 to action (task) A2. In other words, the outcomes associated with the network of tasks or actions is determined by the actions/tasks of the row player but not the column player. In this case, then, the index of dependence for the sales manager is 1, meaning that her outcomes are completely determined by the other player's actions (tasks). 

![](images/table3c.png)

The index of dependence is computed for every individual in the game so that each person receives his or her own (potentially) unique value, but @victor_interdependence_1987 also provide a team-level index called the index of correspondence which captures the overlap between rewards governed by an individual's own actions (tasks) and those governed by other's actions (tasks). Imagine a system in which all players have some control over their outcomes given their task choices. Susan, for instance, can choose between writing (task 1) or scheduling meetings (task 2) and those tasks lead to different outcomes such that she has a preference for one over the other. Jackie also has task choices, she can choose to analyze data (task 1) or update the scripts for her shared website with Susan to improve its security (task 2). To the extent that Jackie's task choices influence Susan's outcomes irrespective of whether Susan chooses to write or schedule, Susan's index of dependence will increase -- her outcomes depend not only on her actions or tasks but also on Jackie's. The index of correspondence, conversely, is about the alignment of choices under one's own control with those not under one's own control. To what extent does the unit share preferences for actions, task completions, or task choices? One individual can collect different rewards for making different choices, but rewards are also determined by what the other player's choose. To what extent do those two tensions align?

### Recommendations, Challenges, and Next Steps

#### 1 Index compared to self report

#### 2 Index Dynamics

#### 3 apply to field and see what we have. No data on "non perceived" interdependence

#### 4 Purpose and Inference
